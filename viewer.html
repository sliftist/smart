<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Logs Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 10px;
            color: #fff;
            font-size: 20px;
        }

        h3 {
            margin-bottom: 5px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
        }

        .controls {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background: #0052a3;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .date-range-selector {
            margin-top: 8px;
        }

        .date-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 5px;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .date-input-group label {
            font-size: 10px;
            color: #888;
        }

        input[type="datetime-local"] {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        input[type="datetime-local"]:focus {
            outline: none;
            border-color: #0066cc;
        }

        .quick-select-buttons {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .metrics-selector {
            margin-top: 8px;
        }

        .metrics-selector label {
            display: inline-block;
            margin-right: 10px;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
        }

        .metrics-selector input[type="checkbox"] {
            margin-right: 3px;
            cursor: pointer;
        }

        .chart-container {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .chart-wrapper {
            position: relative;
            height: 600px;
        }

        canvas {
            background: #1a1a1a;
            border-radius: 4px;
        }

        .info {
            color: #888;
            margin-top: 5px;
            font-size: 12px;
        }

        .error {
            background: #ff4444;
            color: white;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 12px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #2a2a2a;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 12px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            color: #fff;
            font-size: 16px;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            margin: 0;
        }

        .modal-close:hover {
            color: #fff;
            background: none;
        }

        .modal-body {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .label-input-group {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .label-input-group label {
            font-size: 11px;
            color: #888;
        }

        .label-input-group input {
            background: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 5px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        .label-input-group input:focus {
            outline: none;
            border-color: #0066cc;
        }

        .modal-footer {
            padding: 12px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div style="display: flex; flex-direction: row; gap: 5px; align-items: center;">
                <button id="selectFolder">Select Logs Folder</button>
                <button id="enableAccess" style="display: none;">Enable Folder Access</button>
                <button id="labelIds" style="display: none;">Label IDs</button>
                <div id="folderInfo" class="info"></div>
            </div>
            
            <div id="dateRangeContainer" style="display: none;" class="date-range-selector">
                <h3>Select Date Range:</h3>
                <div style="margin-bottom: 5px; display: flex; gap: 10px; flex-wrap: wrap; font-size: 12px;">
                    <label style="cursor: pointer; user-select: none;">
                        <input type="checkbox" id="liveRangeCheckbox" style="cursor: pointer; margin-right: 3px;">
                        <strong>Live Range</strong> (4 hours past → 1 hour future)
                    </label>
                    <label style="cursor: pointer; user-select: none;">
                        <input type="checkbox" id="autoRefreshCheckbox" style="cursor: pointer; margin-right: 3px;">
                        <strong>Auto-load data</strong>
                    </label>
                </div>
                <div class="date-inputs">
                    <div class="date-input-group">
                        <label>Start Date & Time</label>
                        <input type="datetime-local" id="startDateTime">
                    </div>
                    <div class="date-input-group">
                        <label>End Date & Time</label>
                        <input type="datetime-local" id="endDateTime">
                    </div>
                    <button id="loadRange">Load Data</button>
                    
                    <button id="lastDay">Last 24 Hours</button>
                    <button id="lastWeek">Last 7 Days</button>
                    <button id="allData">All Available Data</button>
                </div>
            </div>

            <div id="metricsContainer" style="display: none;" class="metrics-selector">
                <h3>Metrics to Display:</h3>
                <!-- Checkboxes will be generated dynamically from METRICS_CONFIG -->
            </div>
        </div>

        <div id="chartContainer" class="chart-container" style="display: none;">
            <div class="chart-wrapper">
                <canvas id="chart"></canvas>
            </div>
        </div>

        <div id="error" style="display: none;" class="error"></div>
    </div>

    <!-- Label IDs Modal -->
    <div id="labelModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Label IDs</h2>
                <button class="modal-close" id="closeModal">&times;</button>
            </div>
            <div class="modal-body" id="labelModalBody">
                <!-- Will be populated dynamically -->
            </div>
            <div class="modal-footer">
                <button id="saveLabels">Save</button>
                <button id="cancelLabels">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let logsDirectoryHandle = null;
        let currentData = [];
        let availableFiles = [];
        let selectedStartDate = null;
        let selectedEndDate = null;
        let chartInstance = null;
        let visibleDatasets = new Set(); // Track visible dataset IDs (default all hidden)
        let autoRefreshInterval = null; // Track auto-refresh interval
        let idLabels = {}; // Store labels for IDs

        const colors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7',
            '#fd79a8', '#fdcb6e', '#e17055', '#74b9ff', '#a29bfe',
            '#55efc4', '#ffeaa7', '#fab1a0', '#ff7675', '#00b894'
        ];

        // ===== METRIC CONFIGURATION - ADD NEW METRICS HERE =====
        const METRICS_CONFIG = [
            {
                key: 'temperature_C',
                label: 'Temperature (°C)',
                baseId: 'temperature_celsius', // Groups with other Celsius temperature metrics
                defaultChecked: true,
                borderDash: [], // Solid line
                isEventData: false // Line chart
            },
            {
                key: 'humidity',
                label: 'Humidity (%)',
                baseId: 'humidity',
                defaultChecked: true,
                borderDash: [5, 5], // Dashed
                isEventData: false
            },
            {
                key: 'absolute_humidity',
                label: 'Absolute Humidity (g/m³)',
                baseId: 'absolute_humidity',
                defaultChecked: false,
                borderDash: [8, 3, 2, 3], // Dash-dot
                isEventData: false
            },
            {
                key: 'rssi',
                label: 'RSSI (dB)',
                baseId: 'signal', // Groups with SNR and noise
                defaultChecked: false,
                borderDash: [2, 3], // Short dash
                isEventData: false
            },
            {
                key: 'snr',
                label: 'SNR (dB)',
                baseId: 'signal', // Groups with RSSI and noise
                defaultChecked: false,
                borderDash: [10, 3, 2, 3], // Dash-dot
                isEventData: false
            },
            {
                key: 'noise',
                label: 'Noise (dB)',
                baseId: 'signal', // Groups with RSSI and SNR
                defaultChecked: false,
                borderDash: [1, 3], // Dotted
                isEventData: false
            },
            {
                key: 'plugOn',
                label: 'Plug On',
                baseId: 'binary', // Groups with other binary/boolean metrics
                defaultChecked: false,
                borderDash: [15, 3], // Long dash
                isEventData: true // Binary event - show as points only
            },
            // HVAC/Thermostat metrics
            {
                key: 'is_cooling',
                label: 'Is Cooling',
                baseId: 'binary', // Groups with other binary/boolean metrics
                defaultChecked: false,
                borderDash: [12, 4], // Long dash
                isEventData: false
            },
            {
                key: 'is_heating',
                label: 'Is Heating',
                baseId: 'binary', // Groups with other binary/boolean metrics
                defaultChecked: false,
                borderDash: [12, 4], // Long dash
                isEventData: false
            },
            {
                key: 'is_fan_running',
                label: 'Is Fan Running',
                baseId: 'binary', // Groups with other binary/boolean metrics
                defaultChecked: false,
                borderDash: [12, 4], // Long dash
                isEventData: false
            },
            {
                key: 'temperature_celsius',
                label: 'HVAC Temperature (°C)',
                baseId: 'temperature_celsius', // Groups with other Celsius temperature metrics
                defaultChecked: false,
                borderDash: [], // Solid line
                isEventData: false
            },
            {
                key: 'temperature_fahrenheit',
                label: 'HVAC Temperature (°F)',
                baseId: 'temperature_fahrenheit', // Separate axis for Fahrenheit
                defaultChecked: false,
                borderDash: [], // Solid line
                isEventData: false
            },
            {
                key: 'heating_set_point_celsius',
                label: 'Heating Set Point (°C)',
                baseId: 'temperature_celsius', // Groups with other Celsius set points
                defaultChecked: false,
                borderDash: [6, 2], // Medium dash
                isEventData: false
            },
            {
                key: 'heating_set_point_fahrenheit',
                label: 'Heating Set Point (°F)',
                baseId: 'temperature_fahrenheit', // Groups with other Fahrenheit set points
                defaultChecked: false,
                borderDash: [6, 2], // Medium dash
                isEventData: false
            },
            {
                key: 'cooling_set_point_celsius',
                label: 'Cooling Set Point (°C)',
                baseId: 'temperature_celsius', // Groups with other Celsius set points
                defaultChecked: false,
                borderDash: [3, 2, 1, 2], // Dash-dot-dot
                isEventData: false
            },
            {
                key: 'cooling_set_point_fahrenheit',
                label: 'Cooling Set Point (°F)',
                baseId: 'temperature_fahrenheit', // Groups with other Fahrenheit set points
                defaultChecked: false,
                borderDash: [3, 2, 1, 2], // Dash-dot-dot
                isEventData: false
            }
        ];
        // ===== END METRIC CONFIGURATION =====

        // Generate metric checkboxes from configuration
        function initializeMetricCheckboxes() {
            const container = document.getElementById('metricsContainer');
            const h3 = container.querySelector('h3');
            
            // Clear existing checkboxes (except the h3)
            container.innerHTML = '';
            container.appendChild(h3);
            
            // Generate checkboxes from config
            METRICS_CONFIG.forEach(metric => {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.value = metric.key;
                if (metric.defaultChecked) {
                    input.checked = true;
                }
                
                label.appendChild(input);
                label.appendChild(document.createTextNode(' ' + metric.label));
                container.appendChild(label);
                
                // Add event listener for changes
                input.addEventListener('change', () => {
                    updateURL();
                    if (currentData.length > 0) {
                        drawChart();
                    }
                });
            });
        }

        // Calculate absolute humidity from temperature (°C) and relative humidity (%)
        function calculateAbsoluteHumidity(tempC, relativeHumidity) {
            if (tempC === undefined || relativeHumidity === undefined) return undefined;
            
            // Using the Magnus-Tetens approximation
            // AH = (RH/100) × (6.112 × e^((17.67 × T)/(T + 243.5)) × 2.1674) / (273.15 + T)
            const saturationVaporPressure = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
            const actualVaporPressure = (relativeHumidity / 100) * saturationVaporPressure;
            const absoluteHumidity = (actualVaporPressure * 2.1674) / (273.15 + tempC);
            
            return absoluteHumidity;
        }

        // Label management functions
        function loadLabels() {
            const saved = localStorage.getItem('radioIdLabels');
            if (saved) {
                try {
                    idLabels = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to parse saved labels:', e);
                    idLabels = {};
                }
            }
        }

        function saveLabels() {
            localStorage.setItem('radioIdLabels', JSON.stringify(idLabels));
        }

        function getDisplayName(id) {
            if (idLabels[id] && idLabels[id].trim()) {
                return `${idLabels[id]} (${id})`;
            }
            return id;
        }

        function getAllUniqueIds() {
            const ids = new Set();
            currentData.forEach(entry => {
                if (entry.id) {
                    ids.add(entry.id);
                }
            });
            return Array.from(ids).sort();
        }

        function openLabelModal() {
            const uniqueIds = getAllUniqueIds();
            const modalBody = document.getElementById('labelModalBody');
            
            // Clear existing content
            modalBody.innerHTML = '';
            
            if (uniqueIds.length === 0) {
                modalBody.innerHTML = '<p style="color: #888;">No IDs found in current data. Please load data first.</p>';
            } else {
                uniqueIds.forEach(id => {
                    const group = document.createElement('div');
                    group.className = 'label-input-group';
                    
                    const label = document.createElement('label');
                    label.textContent = `ID: ${id}`;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = idLabels[id] || '';
                    input.placeholder = 'Enter label (optional)';
                    input.dataset.id = id;
                    
                    group.appendChild(label);
                    group.appendChild(input);
                    modalBody.appendChild(group);
                });
            }
            
            document.getElementById('labelModal').style.display = 'flex';
        }

        function closeLabelModal() {
            document.getElementById('labelModal').style.display = 'none';
        }

        function saveLabelChanges() {
            const inputs = document.querySelectorAll('#labelModalBody input[data-id]');
            inputs.forEach(input => {
                const id = input.dataset.id;
                const value = input.value.trim();
                if (value) {
                    idLabels[id] = value;
                } else {
                    delete idLabels[id];
                }
            });
            saveLabels();
            closeLabelModal();
            
            // Redraw chart if data is loaded
            if (currentData.length > 0) {
                drawChart();
            }
        }

        // IndexedDB for persisting directory handle
        const DB_NAME = 'RadioLogsDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'settings';

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }

        async function saveDirectoryHandle(handle) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(handle, 'logsDirectory');
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function loadDirectoryHandle() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get('logsDirectory');
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function requestPersistentPermission() {
            if (navigator.storage && navigator.storage.persist) {
                const isPersisted = await navigator.storage.persist();
                console.log(`Persistent storage: ${isPersisted ? 'granted' : 'denied'}`);
                return isPersisted;
            }
            return false;
        }

        async function verifyPermission(handle, readWrite = false, skipRequest = false) {
            const options = { mode: readWrite ? 'readwrite' : 'read' };
            
            // Check if permission was already granted
            if ((await handle.queryPermission(options)) === 'granted') {
                return true;
            }
            
            // Skip request if specified (for automatic checks without user interaction)
            if (skipRequest) {
                return false;
            }
            
            // Request permission (requires user interaction)
            if ((await handle.requestPermission(options)) === 'granted') {
                return true;
            }
            
            return false;
        }

        async function initializeWithSavedHandle() {
            try {
                const savedHandle = await loadDirectoryHandle();
                if (savedHandle) {
                    // Store the handle for later use
                    logsDirectoryHandle = savedHandle;
                    
                    // Verify we still have permission (skip automatic request)
                    if (await verifyPermission(savedHandle, false, true)) {
                        // Permission already granted
                        await loadAvailableFiles();
                        document.getElementById('folderInfo').textContent = `✓ Loaded: ${logsDirectoryHandle.name}`;
                        document.getElementById('dateRangeContainer').style.display = 'block';
                        document.getElementById('selectFolder').textContent = 'Change Logs Folder';
                    } else {
                        // Permission needs to be requested with user interaction
                        document.getElementById('enableAccess').style.display = 'inline-block';
                        document.getElementById('folderInfo').textContent = `Folder: ${logsDirectoryHandle.name} - Click "Enable Folder Access" to continue`;
                    }
                }
            } catch (err) {
                console.log('No saved directory handle or error loading:', err);
            }
        }

        // Select folder button
        document.getElementById('selectFolder').addEventListener('click', async () => {
            try {
                logsDirectoryHandle = await window.showDirectoryPicker();
                
                // Request persistent storage
                await requestPersistentPermission();
                
                // Save handle to IndexedDB
                await saveDirectoryHandle(logsDirectoryHandle);
                
                await loadAvailableFiles();
                document.getElementById('folderInfo').textContent = `✓ Loaded: ${logsDirectoryHandle.name}`;
                document.getElementById('dateRangeContainer').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                document.getElementById('selectFolder').textContent = 'Change Logs Folder';
                document.getElementById('enableAccess').style.display = 'none';
            } catch (err) {
                if (err.name !== 'AbortError') {
                    showError('Failed to access folder: ' + err.message);
                }
            }
        });

        // Enable access button (for requesting permission with user interaction)
        document.getElementById('enableAccess').addEventListener('click', async () => {
            try {
                if (logsDirectoryHandle) {
                    // Request permission with user interaction
                    if (await verifyPermission(logsDirectoryHandle, false, false)) {
                        await loadAvailableFiles();
                        document.getElementById('folderInfo').textContent = `✓ Loaded: ${logsDirectoryHandle.name}`;
                        document.getElementById('dateRangeContainer').style.display = 'block';
                        document.getElementById('error').style.display = 'none';
                        document.getElementById('selectFolder').textContent = 'Change Logs Folder';
                        document.getElementById('enableAccess').style.display = 'none';
                        
                        // If we have a saved range, load it now
                        if (selectedStartDate && selectedEndDate) {
                            await loadDateRange(selectedStartDate, selectedEndDate);
                        }
                    } else {
                        showError('Permission to access folder was denied. Please select the folder again.');
                    }
                }
            } catch (err) {
                showError('Failed to enable folder access: ' + err.message);
            }
        });

        function updateURL() {
            const params = new URLSearchParams();
            
            if (selectedStartDate) {
                params.set('start', selectedStartDate.toString());
            }
            
            if (selectedEndDate) {
                params.set('end', selectedEndDate.toString());
            }
            
            const selectedMetrics = getSelectedMetrics();
            if (selectedMetrics.length > 0) {
                params.set('metrics', selectedMetrics.join(','));
            }
            
            // Save visible datasets (only store the ones explicitly shown)
            if (visibleDatasets.size > 0) {
                params.set('visible', Array.from(visibleDatasets).join('|||'));
            }
            
            // Save live range checkbox state
            const liveRangeCheckbox = document.getElementById('liveRangeCheckbox');
            if (liveRangeCheckbox && liveRangeCheckbox.checked) {
                params.set('liveRange', 'true');
            }
            
            // Save auto-refresh checkbox state
            const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
            if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
                params.set('autoRefresh', 'true');
            }
            
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({}, '', newURL);
        }

        function restoreFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Restore metrics
            const metricsParam = params.get('metrics');
            if (metricsParam) {
                const metrics = metricsParam.split(',');
                document.querySelectorAll('.metrics-selector input[type="checkbox"]').forEach(cb => {
                    cb.checked = metrics.includes(cb.value);
                });
            }
            
            // Restore visible datasets
            const visibleParam = params.get('visible');
            const visibleDatasets = visibleParam ? visibleParam.split('|||') : [];
            
            // Restore live range checkbox
            const liveRange = params.get('liveRange') === 'true';
            
            // Restore auto-refresh checkbox
            const autoRefresh = params.get('autoRefresh') === 'true';
            
            // Restore date range (stored as timestamps)
            return {
                start: params.get('start') ? parseInt(params.get('start'), 10) : null,
                end: params.get('end') ? parseInt(params.get('end'), 10) : null,
                visible: visibleDatasets,
                liveRange: liveRange,
                autoRefresh: autoRefresh
            };
        }

        function setLiveRange() {
            const now = Date.now();
            const start = now - 4 * 60 * 60 * 1000; // 4 hours ago
            const end = now + 1 * 60 * 60 * 1000; // 1 hour future
            
            document.getElementById('startDateTime').value = formatDateTimeLocal(start);
            document.getElementById('endDateTime').value = formatDateTimeLocal(end);
            
            return { start, end };
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize metric checkboxes from configuration
            initializeMetricCheckboxes();
            
            // Load saved labels
            loadLabels();
            
            const savedRange = restoreFromURL();
            
            // Restore visible datasets
            if (savedRange.visible && savedRange.visible.length > 0) {
                visibleDatasets = new Set(savedRange.visible);
            }
            
            // Restore and handle live range checkbox
            const liveRangeCheckbox = document.getElementById('liveRangeCheckbox');
            if (savedRange.liveRange) {
                liveRangeCheckbox.checked = true;
            }
            
            // Restore auto-refresh checkbox
            const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
            if (savedRange.autoRefresh) {
                autoRefreshCheckbox.checked = true;
            }
            
            // Store the date range for later use
            if (savedRange.liveRange) {
                const { start, end } = setLiveRange();
                selectedStartDate = start;
                selectedEndDate = end;
            } else if (savedRange.start && savedRange.end) {
                selectedStartDate = savedRange.start;
                selectedEndDate = savedRange.end;
                document.getElementById('startDateTime').value = formatDateTimeLocal(savedRange.start);
                document.getElementById('endDateTime').value = formatDateTimeLocal(savedRange.end);
            }
            
            // Try to initialize with saved handle
            await initializeWithSavedHandle();
            
            // If we have a handle and permissions, load data and start auto-refresh
            if (logsDirectoryHandle && document.getElementById('dateRangeContainer').style.display === 'block') {
                if (selectedStartDate && selectedEndDate) {
                    await loadDateRange(selectedStartDate, selectedEndDate);
                }
                
                // Start auto-refresh if enabled
                if (savedRange.autoRefresh) {
                    startAutoRefresh();
                }
            }
        });

        function formatDateTimeLocal(timestamp) {
            const date = new Date(timestamp);
            const pad = (n) => n.toString().padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
        }

        async function loadAvailableFiles() {
            availableFiles = [];

            for await (const entry of logsDirectoryHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/^\d{4}-\d{2}-\d{2}-/)) {
                    const match = entry.name.match(/^(\d{4}-\d{2}-\d{2})-/);
                    if (match) {
                        // Store as start/end timestamps for the day
                        const dateStr = match[1];
                        const startOfDay = new Date(dateStr + 'T00:00:00').getTime();
                        const endOfDay = new Date(dateStr + 'T23:59:59.999').getTime();
                        availableFiles.push({ 
                            startOfDay: startOfDay,
                            endOfDay: endOfDay,
                            handle: entry 
                        });
                    }
                }
            }

            availableFiles.sort((a, b) => b.startOfDay - a.startOfDay); // Sort newest first

            // Set default date range to the most recent day if available
            if (availableFiles.length > 0) {
                const now = Date.now();
                document.getElementById('endDateTime').value = formatDateTimeLocal(now);
                
                const yesterday = now - 24 * 60 * 60 * 1000;
                document.getElementById('startDateTime').value = formatDateTimeLocal(yesterday);
            }
        }

        async function loadDateRange(startTime, endTime) {
            let time = Date.now();
            try {
                selectedStartDate = startTime;
                selectedEndDate = endTime;
                
                // Find all files that might contain data in this range
                // File objects have startOfDay and endOfDay timestamps
                const filesToLoad = availableFiles.filter(file => {
                    // Include file if it overlaps with our time range at all
                    return file.endOfDay >= startTime && file.startOfDay <= endTime;
                });

                if (filesToLoad.length === 0) {
                    showError('No log files found for the selected date range');
                    return;
                }

                currentData = [];

                let time = Date.now();
                
                // Load all files in the range
                await Promise.all(filesToLoad.map(async (fileInfo) => {
                    const file = await fileInfo.handle.getFile();
                    const text = await file.text();
                    const lines = text.trim().split('\n');
                    console.log(`Read ${text.length} characters in`);
                    
                    let time = Date.now();
                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                const json = JSON.parse(line);
                                const entryTime = new Date(json.time).getTime();
                                let id = json.id;
                                if (!json.id) continue;

                                // if(!["ecobee", 154].includes(json.id)) {
                                //     continue;
                                // }
                                
                                let hasANumber = /\d/.test(json.id);
                                // These are outside devices
                                if (/^[0-9A-Fa-f]{6}$/.test(json.id) && hasANumber) {
                                    continue;
                                }
                                if (/^[0-9A-Fa-f]{7}$/.test(json.id) && hasANumber) {
                                    continue;
                                }
                                if (/^[0-9A-Fa-f]{8}$/.test(json.id) && hasANumber) {
                                    continue;
                                }
                                
                                // Only include entries within the time range
                                if (entryTime >= startTime && entryTime <= endTime) {
                                    // Calculate absolute humidity if temperature and humidity are present
                                    if (json.temperature_C !== undefined && json.humidity !== undefined) {
                                        json.absolute_humidity = calculateAbsoluteHumidity(json.temperature_C, json.humidity);
                                    }
                                    
                                    // Store time as timestamp (number) instead of string
                                    json.time = entryTime;
                                    currentData.push(json);
                                }
                            } catch (e) {
                                // Skip invalid JSON lines
                            }
                        }
                    }
                    let duration = Date.now() - time;
                    console.log(`Loaded ${lines.length} lines in ${(duration / 1000).toFixed(2)}s`);
                }).map(x => x.catch(err => {
                    console.error(`Error loading file ${fileInfo.handle.name}: ${err}`);
                })));

                // Sort by time (now numeric timestamps)
                currentData.sort((a, b) => a.time - b.time);

                let duration = Date.now() - time;
                console.log(`Sorted ${currentData.length} data points in ${(duration / 1000).toFixed(2)}s`);

                document.getElementById('metricsContainer').style.display = 'block';
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('labelIds').style.display = 'inline-block';
                document.getElementById('error').style.display = 'none';
                updateURL();
                drawChart();
            } catch (err) {
                showError('Failed to load log files: ' + err.message);
            }
            console.log(`Loaded data in ${Date.now() - time}ms`);
        }

        // Load Range button
        document.getElementById('loadRange').addEventListener('click', async () => {
            const startInput = document.getElementById('startDateTime').value;
            const endInput = document.getElementById('endDateTime').value;
            
            if (!startInput || !endInput) {
                showError('Please select both start and end date/time');
                return;
            }
            
            const startTime = new Date(startInput).getTime();
            const endTime = new Date(endInput).getTime();
            
            if (startTime >= endTime) {
                showError('Start date must be before end date');
                return;
            }
            
            await loadDateRange(startTime, endTime);
        });

        // Last 24 hours button
        document.getElementById('lastDay').addEventListener('click', async () => {
            const end = Date.now();
            const start = end - 24 * 60 * 60 * 1000;
            
            document.getElementById('startDateTime').value = formatDateTimeLocal(start);
            document.getElementById('endDateTime').value = formatDateTimeLocal(end);
            
            await loadDateRange(start, end);
        });

        // Last 7 days button
        document.getElementById('lastWeek').addEventListener('click', async () => {
            const end = Date.now();
            const start = end - 7 * 24 * 60 * 60 * 1000;
            
            document.getElementById('startDateTime').value = formatDateTimeLocal(start);
            document.getElementById('endDateTime').value = formatDateTimeLocal(end);
            
            await loadDateRange(start, end);
        });

        // All data button
        document.getElementById('allData').addEventListener('click', async () => {
            if (availableFiles.length === 0) {
                showError('No log files available');
                return;
            }
            
            const start = availableFiles[availableFiles.length - 1].startOfDay;
            const end = Date.now();
            
            document.getElementById('startDateTime').value = formatDateTimeLocal(start);
            document.getElementById('endDateTime').value = formatDateTimeLocal(end);
            
            await loadDateRange(start, end);
        });

        // Listen to live range checkbox changes
        document.getElementById('liveRangeCheckbox').addEventListener('change', async (e) => {
            if (e.target.checked) {
                // Set to live range
                const { start, end } = setLiveRange();
                updateURL();
                if (logsDirectoryHandle) {
                    await loadDateRange(start, end);
                }
            } else {
                // Unchecked - just update URL to remove the parameter
                updateURL();
            }
        });

        // Listen to auto-refresh checkbox changes
        document.getElementById('autoRefreshCheckbox').addEventListener('change', (e) => {
            if (e.target.checked) {
                startAutoRefresh();
            } else {
                stopAutoRefresh();
            }
            updateURL();
        });

        // Label IDs button
        document.getElementById('labelIds').addEventListener('click', openLabelModal);

        // Modal controls
        document.getElementById('closeModal').addEventListener('click', closeLabelModal);
        document.getElementById('cancelLabels').addEventListener('click', closeLabelModal);
        document.getElementById('saveLabels').addEventListener('click', saveLabelChanges);

        // Close modal when clicking outside
        document.getElementById('labelModal').addEventListener('click', (e) => {
            if (e.target.id === 'labelModal') {
                closeLabelModal();
            }
        });

        function startAutoRefresh() {
            // Clear any existing interval
            stopAutoRefresh();
            
            autoRefreshInterval = setInterval(async () => {
                if (logsDirectoryHandle && selectedStartDate && selectedEndDate) {
                    // Refresh the list of available files to pick up new log files
                    await loadAvailableFiles();
                    
                    // If live range is enabled, update the range first
                    const liveRangeCheckbox = document.getElementById('liveRangeCheckbox');
                    if (liveRangeCheckbox && liveRangeCheckbox.checked) {
                        const { start, end } = setLiveRange();
                        await loadDateRange(start, end);
                    } else {
                        // Otherwise just reload the current range
                        await loadDateRange(selectedStartDate, selectedEndDate);
                    }
                }
            }, 1000 * 60 * 5);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        function getSelectedMetrics() {
            const metrics = [];
            document.querySelectorAll('.metrics-selector input[type="checkbox"]:checked').forEach(cb => {
                metrics.push(cb.value);
            });
            return metrics;
        }

        function getMetricLabel(metric) {
            const config = METRICS_CONFIG.find(m => m.key === metric);
            return config ? config.label : metric;
        }

        function drawChart() {
            const selectedMetrics = getSelectedMetrics();
            
            if (currentData.length === 0) {
                return;
            }

            if (selectedMetrics.length === 0) {
                return;
            }

            // Destroy existing chart
            if (chartInstance) {
                chartInstance.destroy();
            }

            // Group data by ID and metric
            const dataByIdAndMetric = {};
            
            currentData.forEach(entry => {
                const id = entry.id || 'unknown';
                
                if (!dataByIdAndMetric[id]) {
                    dataByIdAndMetric[id] = {};
                }

                selectedMetrics.forEach(metric => {
                    if (entry[metric] !== undefined) {
                        if (!dataByIdAndMetric[id][metric]) {
                            dataByIdAndMetric[id][metric] = [];
                        }
                        // Convert boolean to number (true -> 1, false -> 0)
                        let value = entry[metric];
                        if (typeof value === 'boolean') {
                            value = value ? 1 : 0;
                        } else {
                            value = parseFloat(value);
                        }
                        dataByIdAndMetric[id][metric].push({
                            x: new Date(entry.time),
                            y: value
                        });
                    }
                });
            });

            // Detect gaps and insert nulls to break lines
            Object.keys(dataByIdAndMetric).forEach(id => {
                Object.keys(dataByIdAndMetric[id]).forEach(metric => {
                    const points = dataByIdAndMetric[id][metric];
                    
                    if (points.length < 2) return;
                    
                    // Sort by time
                    points.sort((a, b) => a.x - b.x);
                    
                    // Calculate typical gap between data points
                    const gaps = [];
                    for (let i = 1; i < points.length; i++) {
                        gaps.push(points[i].x - points[i - 1].x);
                    }
                    
                    // Use median gap as the typical interval
                    gaps.sort((a, b) => a - b);
                    const medianGap = gaps[Math.floor(gaps.length / 2)];
                    const gapThreshold = medianGap * 10; // 10x the typical gap
                    
                    // Insert null values where gaps are too large
                    const processedPoints = [];
                    for (let i = 0; i < points.length; i++) {
                        processedPoints.push(points[i]);
                        
                        if (i < points.length - 1) {
                            const gap = points[i + 1].x - points[i].x;
                            if (gap > gapThreshold) {
                                // Insert a null to break the line
                                processedPoints.push({
                                    x: new Date(points[i].x.getTime() + 1),
                                    y: null
                                });
                            }
                        }
                    }
                    
                    dataByIdAndMetric[id][metric] = processedPoints;
                });
            });

            // Assign colors to each unique ID
            let colorIndex = 0;
            const idColorMap = {};
            Object.keys(dataByIdAndMetric).forEach(id => {
                idColorMap[id] = colors[colorIndex % colors.length];
                colorIndex++;
            });

            // Find the actual time range of the data
            let minTime = null;
            let maxTime = null;
            Object.values(dataByIdAndMetric).forEach(metricsData => {
                Object.values(metricsData).forEach(points => {
                    points.forEach(point => {
                        if (!minTime || point.x < minTime) minTime = point.x;
                        if (!maxTime || point.x > maxTime) maxTime = point.x;
                    });
                });
            });

            // Create datasets for Chart.js
            const datasets = [];
            const yAxes = {};
            const metricToAxisMap = {};
            const baseIdToAxisMap = {};
            let yAxisIndex = 0;

            // First pass: Create Y axes for each unique baseId
            const uniqueBaseIds = new Set();
            selectedMetrics.forEach(metric => {
                const config = METRICS_CONFIG.find(m => m.key === metric);
                if (config && config.baseId) {
                    uniqueBaseIds.add(config.baseId);
                }
            });

            // Create one Y-axis per unique baseId
            Array.from(uniqueBaseIds).forEach(baseId => {
                const yAxisID = `y${yAxisIndex}`;
                baseIdToAxisMap[baseId] = yAxisID;
                
                // Find a representative metric for this baseId to get a label
                const representativeMetric = selectedMetrics.find(metric => {
                    const config = METRICS_CONFIG.find(m => m.key === metric);
                    return config && config.baseId === baseId;
                });
                
                // Get all metric labels that share this baseId
                const metricsWithBaseId = selectedMetrics.filter(metric => {
                    const config = METRICS_CONFIG.find(m => m.key === metric);
                    return config && config.baseId === baseId;
                });
                
                // Create a combined label if multiple metrics share this axis
                let axisLabel = '';
                if (metricsWithBaseId.length === 1) {
                    axisLabel = getMetricLabel(metricsWithBaseId[0]);
                } else {
                    // Use the baseId as a readable label
                    axisLabel = baseId.split('_').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                }
                
                yAxes[yAxisID] = {
                    type: 'linear',
                    display: true,
                    position: yAxisIndex % 2 === 0 ? 'left' : 'right',
                    title: {
                        display: true,
                        text: axisLabel,
                        color: '#888'
                    },
                    ticks: {
                        color: '#888'
                    },
                    grid: {
                        drawOnChartArea: yAxisIndex === 0
                    }
                };
                
                yAxisIndex++;
            });
            
            // Map each metric to its Y-axis based on baseId
            selectedMetrics.forEach(metric => {
                const config = METRICS_CONFIG.find(m => m.key === metric);
                if (config && config.baseId) {
                    metricToAxisMap[metric] = baseIdToAxisMap[config.baseId];
                }
            });

            // Second pass: Create datasets, assigning them to the appropriate Y axis
            Object.entries(dataByIdAndMetric).forEach(([id, metricsData]) => {
                const idColor = idColorMap[id];
                
                selectedMetrics.forEach(metric => {
                    if (metricsData[metric] && metricsData[metric].length > 0) {
                        const yAxisID = metricToAxisMap[metric];
                        
                        // Create dataset
                        const label = `${getDisplayName(id)} - ${getMetricLabel(metric)}`;
                        const metricConfig = METRICS_CONFIG.find(m => m.key === metric);
                        const isEventData = metricConfig ? metricConfig.isEventData : false;
                        const borderDash = metricConfig ? metricConfig.borderDash : [];
                        
                        datasets.push({
                            label: label,
                            id: id, // Store ID for visibility tracking
                            data: metricsData[metric],
                            borderColor: idColor,
                            backgroundColor: idColor,
                            borderWidth: isEventData ? 0 : 2,
                            pointRadius: isEventData ? 6 : 0,
                            pointHoverRadius: isEventData ? 8 : 4,
                            pointStyle: isEventData ? 'circle' : 'circle',
                            tension: 0,
                            stepped: isEventData ? false : 'before',
                            spanGaps: false,
                            showLine: !isEventData,
                            borderDash: borderDash,
                            yAxisID: yAxisID,
                            hidden: !visibleDatasets.has(id),
                            segment: {
                                borderColor: ctx => {
                                    // Don't draw line segments that go beyond actual data
                                    return idColor;
                                }
                            }
                        });
                    }
                });
            });

            // Create the chart
            const ctx = document.getElementById('chart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    animation: false,
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'x',
                        intersect: false
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Data from ${new Date(selectedStartDate).toLocaleString()} to ${new Date(selectedEndDate).toLocaleString()}`,
                            color: '#fff',
                            font: {
                                size: 13,
                                weight: 'bold'
                            },
                            padding: {
                                top: 5,
                                bottom: 5
                            }
                        },
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                color: '#e0e0e0',
                                usePointStyle: true,
                                padding: 8,
                                font: {
                                    size: 11
                                }
                            },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const clickedDataset = chart.data.datasets[index];
                                const clickedId = clickedDataset.id;
                                
                                // Determine if we're hiding or showing based on current state
                                const currentMeta = chart.getDatasetMeta(index);
                                const shouldHide = currentMeta.hidden === null ? !clickedDataset.hidden : null;
                                
                                // Toggle visibility for ALL datasets with this ID
                                chart.data.datasets.forEach((dataset, i) => {
                                    if (dataset.id === clickedId) {
                                        const meta = chart.getDatasetMeta(i);
                                        meta.hidden = shouldHide;
                                    }
                                });
                                
                                // Update visible datasets set
                                if (shouldHide) {
                                    visibleDatasets.delete(clickedId);
                                } else {
                                    visibleDatasets.add(clickedId);
                                }
                                
                                chart.update();
                                updateURL();
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(42, 42, 42, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#e0e0e0',
                            borderColor: '#444',
                            borderWidth: 1,
                            filter: function(tooltipItem, index, tooltipItems) {
                                // Remove duplicates by checking if this label already appeared
                                const label = tooltipItem.dataset.label;
                                return tooltipItems.findIndex(item => item.dataset.label === label) === index;
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    hour: 'HH:mm',
                                    minute: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                color: '#888'
                            },
                            ticks: {
                                color: '#888'
                            },
                            grid: {
                                color: '#333'
                            }
                        },
                        ...yAxes
                    }
                }
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (currentData.length > 0) {
                    drawChart();
                }
            }, 250);
        });
    </script>
</body>
</html>

